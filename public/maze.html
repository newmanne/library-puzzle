<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Restricted Stacks â€” VigenÃ¨re Build (Maze)</title>
  <style>
    :root{
      --bg:#0c0f12;           /* deep library midnight */
      --panel:#12161b;        /* terminal well */
      --ink:#e6edf3;          /* readable text */
      --muted:#9aa7b2;        /* secondary */
      --accent:#caa46b;       /* brass plaque */
      --link:#8fb0ff;         /* subtle blue */
    }
    html,body{height:100%;}
    body{
      margin:0; background:linear-gradient(180deg, #0c0f12 0%, #0e1116 60%, #0c0f12 100%);
      color:var(--ink); font:16px/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      display:flex; flex-direction:column; align-items:center; justify-content:stretch;
    }
    header{max-width:1020px; width:100%; padding:20px 16px 8px; box-sizing:border-box;}
    h1{margin:0 0 4px; font-size:20px; font-weight:700; letter-spacing:0.5px;}
    .subtitle{color:var(--muted); font-size:13px}

    .terminal{ max-width:1020px; width:100%; flex:1; display:flex; flex-direction:column; box-sizing:border-box;
      background:var(--panel); border:1px solid #1d232b; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.35);
      overflow:hidden; margin:8px 16px 16px; }
    #view{ padding:18px; overflow:auto; white-space:pre-wrap; word-break:break-word; flex:1; scroll-behavior:smooth; }
    #view::-webkit-scrollbar{width:10px;height:10px}
    #view::-webkit-scrollbar-thumb{background:#222b35;border-radius:10px}

    .line{margin:0 0 4px;}
    .line .prompt{color:#7bc275}
    .line .muted{color:var(--muted)}
    .line .accent{color:var(--accent)}
    .exits{color:var(--link)}

    form#cmdbar{display:flex; gap:10px; border-top:1px solid #1d232b; padding:12px 14px; align-items:center; background:rgba(255,255,255,0.02)}
    #promptGlyph{color:#7bc275}
    #cmd{ flex:1; background:#0e1318; color:var(--ink); border:1px solid #1b2129; border-radius:8px; padding:10px 12px;
      outline:none; font:15px/1.2 ui-monospace, monospace; box-shadow:inset 0 0 0 1px rgba(0,0,0,.25); }
    #cmd::placeholder{color:#61707f}

    .toolbar{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .btn{background:#0e1318; color:var(--ink); border:1px solid #1b2129; border-radius:8px; padding:8px 10px; cursor:pointer; font:13px ui-monospace, monospace}
    .btn:hover{border-color:#293444}
    .btn:active{transform:translateY(1px)}

    .footer{max-width:1020px; width:100%; padding:0 16px 18px; color:var(--muted); font-size:12px; box-sizing:border-box}

    @media (max-width:640px){ body{font-size:15px;} }
  </style>
</head>
<body>
  <header>
    <h1>ðŸ“š Lost in The Stacks</h1>
    <div class="subtitle">Text adventure!</div>
  </header>

  <div class="terminal" role="region" aria-label="Adventure terminal">
    <div id="view" aria-live="polite" aria-atomic="false"></div>
    <form id="cmdbar" autocomplete="off">
      <span id="promptGlyph" aria-hidden="true">&gt;</span>
      <input id="cmd" name="cmd" placeholder="Enter a command (e.g., n; e; look; pull book; read primer; maze)" autofocus />
      <div class="toolbar">
        <button type="button" class="btn" id="btnHelp" title="Help">help</button>
        <button type="button" class="btn" id="btnLook" title="Look">look</button>
        <button type="button" class="btn" id="btnSettings" aria-expanded="false" title="Settings">âš™ï¸Ž</button>
      </div>
    </form>
  </div>
  <div class="footer">

  <dialog id="settingsDialog">
    <form method="dialog" style="min-width: min(640px, 90vw); background:#0e1318; color:var(--ink); border:1px solid #1b2129; border-radius:12px; padding:16px;">
      <h3 style="margin:0 0 8px">Settings</h3>
      <div style="display:grid; grid-template-columns: auto 1fr; gap:8px 12px; align-items:center; font:14px ui-monospace, monospace;">
        <label for="speed">Typing speed (ms/char)</label>
        <input id="speed" type="number" min="0" step="5" value="9" style="background:#0c1116;color:var(--ink);border:1px solid #1b2129;border-radius:8px;padding:6px 8px;">
        <label>Instant text</label>
        <input id="instantToggle" type="checkbox">
        <label>High contrast</label>
        <input id="contrastToggle" type="checkbox">
        <label>Show debug</label>
        <input id="debugToggle" type="checkbox">
        <label>Last response only</label>
        <input id="lastOnlyToggle" type="checkbox" checked>
        <label>Reveal maze map on look (debug)</label>
        <input id="revealMapToggle" type="checkbox">
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:14px">
        <button class="btn" value="cancel">Close</button>
      </div>
    </form>
  </dialog>

  <script>
  /********************
   * Utility & PRNG   *
   ********************/
  function hashStringToInt(str){ let h = 2166136261 >>> 0; for (let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); } return h >>> 0; }
  function mulberry32(a){ return function(){ a |= 0; a = a + 0x6D2B79F5 | 0; let t = Math.imul(a ^ a >>> 15, 1 | a); t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t; return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
  function pick(rng, arr){ return arr[Math.floor(rng()*arr.length)] }
  const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));

  /********************
   * Dimensions & Params *
   ********************/
  const WIDTH = 10, HEIGHT = 8; // expanded play-space (+2 cols, +2 rows) // widened horizontally for bigger play-space
  const urlParams = new URLSearchParams(location.search);
  const seedParam = urlParams.get('seed') || 'RESTRICTED-STACKS-VIG'; // controls signal placements only
  const runSelfTestsParam = urlParams.get('selftest') === '1';
  const SEED = hashStringToInt(String(seedParam));
  const rng0 = mulberry32(SEED);

  /********************
   * Maze (fixed, deliberate with a few toroidal wraps) *
   ********************/
  const DX = {n:0,e:1,s:0,w:-1};
  const DY = {n:-1,e:0,s:1,w:0};
  const OPP = {n:'s', s:'n', e:'w', w:'e'};

  function buildMaze(W,H,seed){
    const dirs=['n','e','s','w'];
    const grid={}; for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ grid[`${x},${y}`]={}; } }
    const r = mulberry32(seed);
    const stack=[{x:Math.floor(r()*W), y:Math.floor(r()*H)}];
    const seen=new Set([`${stack[0].x},${stack[0].y}`]);
    while(stack.length){
      const cur=stack[stack.length-1];
      const nbrs=dirs.map(d=>({d, nx:cur.x+DX[d], ny:cur.y+DY[d]}))
        .filter(n=> n.nx>=0 && n.nx<W && n.ny>=0 && n.ny<H && !seen.has(`${n.nx},${n.ny}`));
      if(nbrs.length===0){ stack.pop(); continue; }
      const pickN = nbrs[Math.floor(r()*nbrs.length)];
      const a=`${cur.x},${cur.y}`, b=`${pickN.nx},${pickN.ny}`;
      grid[a][pickN.d]=true; grid[b][OPP[pickN.d]]=true;
      seen.add(b); stack.push({x:pickN.nx, y:pickN.ny});
    }
    // A few loops to reduce frustration and add routes
    const extra=Math.floor(W*H*0.12);
    for(let i=0;i<extra;i++){
      const x=Math.floor(r()*W), y=Math.floor(r()*H); const d=dirs[Math.floor(r()*4)];
      const nx=x+DX[d], ny=y+DY[d]; if(nx<0||ny<0||nx>=W||ny>=H) continue;
      grid[`${x},${y}`][d]=true; grid[`${nx},${ny}`][OPP[d]]=true;
    }
    // Toroidal wraps: a few horizontal and vertical wrap corridors
    const hWraps = Math.max(1, Math.floor(W*0.25));
    for(let i=0;i<hWraps;i++){
      const y=Math.floor(r()*H);
      grid[`0,${y}`].w = true; grid[`${W-1},${y}`].e = true; // west<->east
    }
    const vWraps = Math.max(1, Math.floor(H*0.25));
    for(let i=0;i<vWraps;i++){
      const x=Math.floor(r()*W);
      grid[`${x},0`].n = true; grid[`${x},${H-1}`].s = true; // north<->south
    }
    return grid;
  }
  const MAZE = buildMaze(WIDTH, HEIGHT, 0xC0FFEE); // fixed seed â†’ one good maze by default

  function exitsMaze(x,y){ const g=MAZE[`${x},${y}`]||{}; return Object.keys(g).filter(k=>g[k]); }
  function neighborMaze(x,y,dir){
    const g=MAZE[`${x},${y}`]||{}; if(g[dir]){
      const nx=(x+DX[dir]+WIDTH)%WIDTH, ny=(y+DY[dir]+HEIGHT)%HEIGHT; // allow wrap on toroidal edges
      return {x:nx, y:ny, blocked:false};
    }
    return {x,y,blocked:true};
  }

  // Distance helpers to place special rooms deliberately (respect wraps)
  function bfsDistancesFrom(sx,sy){
    const q=[[sx,sy]], dist={}; dist[`${sx},${sy}`]=0; let i=0;
    while(i<q.length){ const [x,y]=q[i++]; const d=dist[`${x},${y}`];
      for(const dir of exitsMaze(x,y)){
        const nx=(x+DX[dir]+WIDTH)%WIDTH, ny=(y+DY[dir]+HEIGHT)%HEIGHT;
        const k=`${nx},${ny}`; if(dist[k]==null){ dist[k]=d+1; q.push([nx,ny]); }
      }
    }
    return dist;
  }
  function farthestCellFrom(sx,sy){ const dist=bfsDistancesFrom(sx,sy); let best={x:sx,y:sy,d:-1}; for(let y=0;y<HEIGHT;y++){ for(let x=0;x<WIDTH;x++){ const d=dist[`${x},${y}`]; if(d!=null && d>best.d){ best={x,y,d}; } } } return best; }
  function cellsAtDistanceRange(sx,sy,min,max,excludeSet){ const dist=bfsDistancesFrom(sx,sy); const out=[]; for(let y=0;y<HEIGHT;y++){ for(let x=0;x<WIDTH;x++){ const k=`${x},${y}`; const d=dist[k]; if(d!=null && d>=min && d<=max && !excludeSet.has(k)) out.push({x,y}); } } return out; }

  /********************
   * Special locations (deliberate placement) *
   ********************/
  const keyOf=(o)=> `${o.x},${o.y}`;
  const START = {x:0, y:0}; // fixed start for a stable experience
  const FAR = farthestCellFrom(START.x, START.y); // ensure Scriptorium is far
  const scriptor = {x:FAR.x, y:FAR.y};

  function pickOne(list, used){ if(list.length===0) return null; const r = Math.floor(rng0()*list.length); let chosen=list[r]; let tries=0; while(used.has(keyOf(chosen)) && tries<list.length){ chosen=list[(r+tries)%list.length]; tries++; } return used.has(keyOf(chosen))?null:chosen; }

  const used=new Set([keyOf(START), keyOf(scriptor)]);
  const nearLF = cellsAtDistanceRange(START.x, START.y, 1, 2, used); // Lost & Found close by
  const lostFound = pickOne(nearLF, used) || {x:1,y:0}; used.add(keyOf(lostFound));
  const midMath = cellsAtDistanceRange(START.x, START.y, 2, 4, used); // Maths Alcove early-ish
  const maths = pickOne(midMath, used) || {x:2,y:0}; used.add(keyOf(maths));
  const midRef  = cellsAtDistanceRange(START.x, START.y, 3, 6, used); // Reference Desk mid
  const refDesk = pickOne(midRef, used) || {x:3,y:0}; used.add(keyOf(refDesk));
  // Vault: one of the most distant spots (not the scriptorium)
  const distFromStart = bfsDistancesFrom(START.x, START.y);
  let farList=[]; for(let y=0;y<HEIGHT;y++){ for(let x=0;x<WIDTH;x++){ const d=distFromStart[`${x},${y}`]; if(d!=null) farList.push({x,y,d}); } }
  farList.sort((a,b)=>b.d-a.d);
  const vault = farList.find(c=> keyOf(c)!==keyOf(scriptor) && !used.has(keyOf(c))) || {x:WIDTH-1,y:HEIGHT-1}; used.add(keyOf(vault));
  const chuteCand = cellsAtDistanceRange(START.x, START.y, 2, 5, used);
  const chute = pickOne(chuteCand, used) || {x:WIDTH-2, y:HEIGHT-2}; used.add(keyOf(chute));

  // Oneness room: demonstrates that all five toggles "on" correspond to value bits set
  const unityCand = cellsAtDistanceRange(START.x, START.y, 2, 6, used);
  const unity = pickOne(unityCand, used) || {x:1, y:HEIGHT-1}; used.add(keyOf(unity));

  const LOST_KEY=keyOf(lostFound), REF_KEY=keyOf(refDesk), MATH_KEY=keyOf(maths), SCRIPTOR_KEY=keyOf(scriptor), VAULT_KEY=keyOf(vault), CHUTE_KEY=keyOf(chute), START_KEY=keyOf(START), UNITY_KEY=keyOf(unity);

  function atLost(x,y){return `${x},${y}`===LOST_KEY}
  function atRef(x,y){return `${x},${y}`===REF_KEY}
  function atMath(x,y){return `${x},${y}`===MATH_KEY}
  function atScribe(x,y){return `${x},${y}`===SCRIPTOR_KEY}
  function atVault(x,y){return `${x},${y}`===VAULT_KEY}
  function atChute(x,y){return `${x},${y}`===CHUTE_KEY}
  function atStart(x,y){return `${x},${y}`===START_KEY}
  function atUnity(x,y){return `${x},${y}`===UNITY_KEY}

  /********************
   * Secret shelf + annex (hidden signal room)
   ********************/
  function findSecretShelf(){
    const dirs=['n','e','s','w'];
    const r = mulberry32((SEED ^ 0xB00B1E)>>>0);
    const cands=[];
    for(let y=0;y<HEIGHT;y++){
      for(let x=0;x<WIDTH;x++){
        const g = MAZE[`${x},${y}`]||{};
        for(const d of dirs){
          const nx = x+DX[d], ny = y+DY[d];
          if(d==='w'&&x===0) continue; if(d==='e'&&x===WIDTH-1) continue; if(d==='n'&&y===0) continue; if(d==='s'&&y===HEIGHT-1) continue;
          if(!g[d]){
            const k2 = `${nx},${ny}`;
            if(!used.has(k2)) cands.push({x,y,dir:d,nx,ny});
          }
        }
      }
    }
    if(!cands.length){ return {x:1,y:1,dir:'e',nx:2,ny:1}; }
    return cands[Math.floor(r()*cands.length)];
  }
  const SECRET = findSecretShelf();
  const SECRET_SHELF = {x:SECRET.x, y:SECRET.y, dir:SECRET.dir};
  const SECRET_ANNEX = {x:SECRET.nx, y:SECRET.ny};
  const SECRET_SHELF_KEY = `${SECRET_SHELF.x},${SECRET_SHELF.y}`;
  const SECRET_ANNEX_KEY = `${SECRET_ANNEX.x},${SECRET_ANNEX.y}`;

  function pickBookSpot(){
    const excl = new Set([...used, SECRET_SHELF_KEY, SECRET_ANNEX_KEY]);
    const pool = cellsAtDistanceRange(START.x, START.y, 2, WIDTH+HEIGHT, excl);
    return pickOne(pool,{ has:(k)=>excl.has(k), add:()=>{} }) || {x:1,y:2};
  }
  const SECRET_BOOK = pickBookSpot();
  const SECRET_BOOK_KEY = `${SECRET_BOOK.x},${SECRET_BOOK.y}`;

  function atSecretShelf(x,y){ return `${x},${y}`===SECRET_SHELF_KEY; }
  function atSecretAnnex(x,y){ return `${x},${y}`===SECRET_ANNEX_KEY; }
  function atSecretBook(x,y){ return `${x},${y}`===SECRET_BOOK_KEY; }

  /********************
   * Cipher placement  *
   ********************/
  const SIGNAL_COUNT = 12; // fixed number of signal rooms
  // No client ciphertext; letters handled server-side

  function chooseUniqueCells(count, banned) { 
    const chosen=new Set(), cells=[];
    let attempts=0; 
    const maxAttempts=10000; 
    const isBanned=(k)=> banned && banned.has(k); 
    while(cells.length<count && attempts<maxAttempts){ 
      const x=Math.floor(rng0()*WIDTH), y=Math.floor(rng0()*HEIGHT);
      const k=`${x},${y}`; 
      if(!isBanned(k) && !chosen.has(k)){ 
        chosen.add(k); cells.push({x,y}); 
      } 
      attempts++; 
    } return cells; 
  }

  const bannedSignals = new Set([...used]);
  let signalCells = chooseUniqueCells(SIGNAL_COUNT, bannedSignals);
  // Ensure the hidden annex is a signal room
  const _annexKey = `${SECRET_ANNEX.x},${SECRET_ANNEX.y}`;
  if(!signalCells.some(c=> `${c.x},${c.y}`===_annexKey)){
    if(signalCells.length>=SIGNAL_COUNT){ signalCells[signalCells.length-1] = {x:SECRET_ANNEX.x, y:SECRET_ANNEX.y}; }
    else { signalCells.push({x:SECRET_ANNEX.x, y:SECRET_ANNEX.y}); }
  }
  function signalHere(x,y){ return null; }


  let visitTitle = null; // per-visit cache of last title shown

  /********************
   * Room description *
   ********************/
  async function roomDescriptor(x,y, normalized){
    const params = new URLSearchParams({ x:String(x), y:String(y), seed:String(seedParam), normalized:String(!!normalized) });
    try{
      const r = await fetch('/api/maze-room?'+params.toString());
      const data = await r.json();
      lastRoom = data || null;
      const lines = (data && data.lines) || ['You are somewhere in the stacks.'];
      const exitsLine = (data && data.exitsLine) || 'Exits: (unknown).';
      return { lines, exitsLine, features: {ukColour:false, ukCatalogue:false, badPlural:false, hyphenEndcap:false, enDash:false}, sig: null };
    }catch(_){
      const lines = ['You are somewhere in the stacks.'];
      const exitsLine = 'Exits: (unknown).';
      return { lines, exitsLine, features: {ukColour:false, ukCatalogue:false, badPlural:false, hyphenEndcap:false, enDash:false}, sig: null };
    }
  }

  /********************
   * Engine & I/O      *
   ********************/
  const view = document.getElementById('view');
  const cmdInput = document.getElementById('cmd');
  const btnHelp = document.getElementById('btnHelp');
  const btnLook = document.getElementById('btnLook');
  const btnSettings = document.getElementById('btnSettings');
  const settingsDialog = document.getElementById('settingsDialog');
  const speedInput = document.getElementById('speed');
  const instantToggle = document.getElementById('instantToggle');
  const contrastToggle = document.getElementById('contrastToggle');
  const debugToggle = document.getElementById('debugToggle');
  const lastOnlyToggle = document.getElementById('lastOnlyToggle');
  const revealMapToggle = document.getElementById('revealMapToggle');

  let typing=false, skipCurrent=false, typeSpeed=Number(speedInput.value);
  document.addEventListener('keydown', (e)=>{ if (e.key==='Escape' && typing){ skipCurrent=true; } });
  speedInput.addEventListener('change', ()=>{ typeSpeed = Math.max(0, Number(speedInput.value)||0); });
  btnSettings.addEventListener('click', ()=> settingsDialog.showModal());
  btnHelp.addEventListener('click', ()=> issue('help'));
  btnLook.addEventListener('click', ()=> issue('look'));
  lastOnlyToggle.addEventListener('change', ()=>{ view.style.overflow = lastOnlyToggle.checked? 'hidden':'auto'; });
  if (lastOnlyToggle.checked) { view.style.overflow = 'hidden'; }

  const queue=[]; function print(text, cls){ queue.push({text,cls}); if(!typing) processQueue(); }
  function processQueue(){ if(queue.length===0){ typing=false; return; } typing=true; const {text,cls}=queue.shift(); const div=document.createElement('div'); div.className='line'+(cls?' '+cls:''); view.appendChild(div); typewrite(div,text,()=>{ view.scrollTop=view.scrollHeight; processQueue(); }); }
  function typewrite(el, text, done){ if (instantToggle.checked || typeSpeed===0){ el.textContent=text; done(); return; } skipCurrent=false; el.textContent=''; let i=0; const tick=()=>{ if(skipCurrent){ el.textContent=text; done(); return; } el.textContent += text[i++]; if(i<text.length){ setTimeout(tick, typeSpeed);} else { done(); } }; setTimeout(tick, typeSpeed); }
  function echoCommand(cmd){ print('> '+cmd, 'prompt'); }
  function clearForLastOnly(){ if(!lastOnlyToggle.checked) return; queue.length=0; typing=false; view.innerHTML=''; }

  function issue(cmd, suppressEcho=false, done){
    if(lastOnlyToggle.checked){ clearForLastOnly(); }
    if(!suppressEcho) echoCommand(cmd);
    parse(cmd);
    if(typeof done==='function') done();
  }

  /********************
   * Game State        *
   ********************/
  const state = {
    x: START.x, y: START.y, steps:0,
    hasCard:false, normalized:false,
    inVault:false, hasSecretBook:false, secretOpen:false
  };
  function hereKey(){ return `${state.x},${state.y}` }

  /********************
   * Map rendering (debug, with signal markers) *
   ********************/
  function asciiMazeLines(){
    const lines=[];
    const isSignal = (x,y)=> false; // server-mode: do not mark signals on debug map
    const baseChar=(x,y)=>{
      if(atStart(x,y)) return 'S';
      if(atScribe(x,y)) return 'T';
      if(atLost(x,y)) return 'F';
      if(atRef(x,y)) return 'R';
      if(atMath(x,y)) return 'A';
      if(atVault(x,y)) return 'V';
      if(atChute(x,y)) return 'C';
      if(atUnity(x,y)) return 'O';
      return ' ';
    };
    for(let y=0;y<HEIGHT;y++){
      // top borders (show wrap gaps on top row)
      let top='+'; for(let x=0;x<WIDTH;x++){ const openN = (MAZE[`${x},${y}`]||{}).n; top += (openN? '   ' : '---') + '+'; } lines.push(top);
      // middle row with left borders; mark signals
      let mid=''; for(let x=0;x<WIDTH;x++){
        const g=MAZE[`${x},${y}`]||{}; const openW = g.w; const bc = baseChar(x,y);
        let ch = bc;
        if(state.x===x && state.y===y){ ch='@'; }
        else if(isSignal(x,y)){
          ch='*';
        }
        mid += (openW? ' ' : '|') + ' ' + ch + ' ';
      }
      // right border: show wrap gap if the last cell has an east wrap
      const openEedge = (MAZE[`${WIDTH-1},${y}`]||{}).e; mid += (openEedge? ' ' : '|');
      lines.push(mid);
    }
    // bottom border (show wrap gaps on bottom row)
    let bottom='+'; for(let x=0;x<WIDTH;x++){ const openSedge = (MAZE[`${x},${HEIGHT-1}`]||{}).s; bottom += (openSedge? '   ' : '---') + '+'; } lines.push(bottom);
    lines.push('Legend: @ you, S start, T scriptorium, F lost&found, R reference, A mathematics, V vault, C chute, O oneness, * signal. Border gaps indicate wrap corridors.');
    return lines;
  }
  function printMaze(){ asciiMazeLines().forEach(s=>print(s)); }

  /********************
   * Core actions      *
   ********************/
  async function look(){
    const d = await roomDescriptor(state.x, state.y, state.normalized);
    d.lines.forEach(t=>print(t));
    print(d.exitsLine, 'exits');
    if(revealMapToggle.checked){ print(''); printMaze(); }
    if (debugToggle.checked){ const ex = exitsMaze(state.x,state.y).join(''); const sigMark = (lastRoom && lastRoom.isSignal)? '*' : '-'; print(`[debug] coords=${state.x},${state.y} sig=${sigMark} exits=${ex}`, 'muted'); }
  }

  async function move(dir){
    if (state.inVault){ if (dir==='e'){ state.inVault=false; clearForLastOnly(); print('You step back into the stacks from the vault.'); visitTitle=null; await look(); } else { clearForLastOnly(); print('Stone walls hem you in. Only east returns you to the stacks.'); } return; }

    // Chute teleport for disorientation
    if (atChute(state.x,state.y) && dir==='s'){
      const rx=Math.floor(rng0()*WIDTH), ry=Math.floor(rng0()*HEIGHT); clearForLastOnly(); print('You drop into the return chuteâ€¦'); state.x=rx; state.y=ry; state.steps++; visitTitle=null; await look(); return; }

    const nb = neighborMaze(state.x, state.y, dir);
    clearForLastOnly();
    if(nb.blocked){ print('Towering shelves block your way.'); return; }
    state.x=nb.x; state.y=nb.y; state.steps++; visitTitle=null; await look();
  }

  function openThing(what){ clearForLastOnly(); if(!what){ print('Open what?'); return; } if(atLost(state.x,state.y) && /(drawer|lost|found|counter)/.test(what)){ print('You slide the shallow drawer open. Inside lies a scuffed library card.'); return; } print("It doesn't seem to open."); }
  function takeThing(what){
    clearForLastOnly();
    if(!what){ print('Take what?'); return;}
    if(atLost(state.x,state.y) && /(card|library card)/.test(what)){
      if(state.hasCard){ print('You already pocketed the card.'); }
      else { state.hasCard=true; print('Taken: a scuffed library card warm from your palm.'); }
      return;
    }
    if(atSecretBook(state.x,state.y) && /(book|secret passage)/i.test(what)){
      if(state.hasSecretBook){ print('You already have the slim volume.'); }
      else { state.hasSecretBook=true; print('Taken: "The Secret Passage". The cover smells faintly of paste.'); }
      return;
    }
    print("You can't take that.");
    if(atLost(state.x,state.y) && /(card|library card)/.test(what)){ if(state.hasCard){ print('You already pocketed the card.'); } else { state.hasCard=true; print('Taken: a scuffed library card warm from your palm.'); } return;} print("You can't take that."); 
  }
  async function readThing(obj){
    clearForLastOnly();
    obj=(obj||'').toLowerCase();
    if(/^(card|library card)$/.test(obj)){
      if(!state.hasCard){ print('You do not seem to have a card.'); return; }
      try{
        const r = await fetch('/api/maze-card');
        const data = await r.json();
        const c = (data && data.card) || { title:'LIBRARY CARD', issuer:'', barcode:'', note:'' };
        print(c.title || 'LIBRARY CARD');
        print('  Patron: ______________');
        if(c.issuer)  print('  Issued by: ' + c.issuer);
        if(c.barcode) print('  Barcode: ' + c.barcode);
        if(c.note)    print('  Note: ' + c.note);
      }catch(_){
        print('LIBRARY CARD');
        print('  Patron: ______________');
        print('  Issued by: â€”');
      }
      return;
    }
    if((/^(primer|chalkboard|slate|math|mathematics|board)$/).test(obj) && atMath(state.x,state.y)){
      print('Primer on the VigenÃ¨re Cipher:');
      print('  1) Ciphertext should be letters Aâ€“Z.');
      print('  2) You will need a KEY to decrypt.');
      print('  3) Encrypt/decrypt by shifting each letter in the ciphertext by the keyword letter.');
      
      return;
    }
    if((/^(plaque|sign|note|instructions)$/).test(obj) && atVault(state.x,state.y)){
      print('The plaque reads:');
      print('  "When you have deciphered the library\'s whisper, speak it here: say <WORD>."');
      return;
    }
    if((/^(librarian|desk|reference|reference desk)$/).test(obj) && atRef(state.x,state.y)){
      print('The librarian murmurs:');
      print('  "Titles sometimes hide an **order**. Cards, a **key**."');
      return;
    }
    print('It is mostly illegible.'); }

  function presentCard(){ clearForLastOnly(); if(!atRef(state.x,state.y)){ print('You wave the card hopefully. Nothing happens.'); return; } if(!state.hasCard){ print('You have no card to present.'); return; } print('The librarian stamps your card and nods. "You will find that some titles are more helpful than others."'); }

  function normalizeCmd(arg){ if(!atScribe(state.x,state.y)){ clearForLastOnly(); print("The scriptorium spell doesn't reach this far."); return; } const a=(arg||'').trim().toLowerCase(); if(a==='on'){ state.normalized=true; } else if(a==='off'){ state.normalized=false; } else { state.normalized=!state.normalized; } clearForLastOnly(); print('Normalization ' + (state.normalized?'on.':'off.')); look(); }

  async function pullBook(){
    clearForLastOnly();
    try{
      const params = new URLSearchParams({ x:String(state.x), y:String(state.y), seed:String(seedParam) });
      const r = await fetch('/api/maze-pull?'+params.toString());
      const data = await r.json();
      const title = (data && data.title) || 'Untitled Monograph';
      const isSig = !!(data && data.isSignal);
      if(isSig){
        print('You slide out a slim volume. Its gilt title reads:');
      } else {
        print('You pull a cracked volume from the shelf. Its title reads:');
      }
      print(`  "${title}."`);
      print('You replace it carefully.');
      visitTitle = title;
    }catch(_){
      print('You tug a book loose, but the spine flakes to dust.');
    }
  }



  async function sayWord(raw){
    clearForLastOnly();
    if(!atVault(state.x,state.y)){ print('Your whisper is swallowed by the stacks.'); return; }
    const spoken = (raw||'').trim(); if(!spoken){ print('Say what?'); return; }
    try{
      const r = await fetch('/api/maze-check', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ word: spoken }) });
      const data = await r.json();
      if(data && data.ok){
        print('The door warms beneath your hand and swings inward. A codex on a lectern lies open to the answer you sought.');
        state.inVault = true;
      } else {
        print('The vault remains cold. The word is not quite right.');
      }
    }catch(_){ print('The vault shudders, then falls silent.'); }
  }




  function placeBook(){
    clearForLastOnly();
    if(!state.hasSecretBook){ print('You have nothing that seems to fit any gap.'); return; }
    if(!atSecretShelf(state.x,state.y)){ print('There\'s no obvious place to put that here.'); return; }
    if(state.secretOpen){ print('The shelf already stands ajar.'); return; }
    const dir=SECRET_SHELF.dir; const a=`${SECRET_SHELF.x},${SECRET_SHELF.y}`; const b=`${SECRET_ANNEX.x},${SECRET_ANNEX.y}`;
    if(!MAZE[a]) MAZE[a]={}; if(!MAZE[b]) MAZE[b]={};
    MAZE[a][dir]=true; MAZE[b][OPP[dir]]=true;
    state.secretOpen=true;
    print('You slide "The Secret Passage" into the waiting gap. With a soft click, the shelving pivots open to the '+{n:'north',e:'east',s:'south',w:'west'}[dir]+'.');
  } 



  function help(){ clearForLastOnly();
    print('Commands:');
    print('  n/e/s/w â€” move (chain with ";" e.g., n;n;e;look)');
    print('  look â€” re-describe this aisle');
    print('  open <drawer> â€” at Lost & Found');
    print('  take <card|book> â€” pick up the library card (keyword) or the slim volume "The Secret Passage"');
    print('  read <card|primer|plaque|librarian> â€” lore & instructions');
    print('  present card â€” at the Reference Desk (flavor hint only)');
    print('  normalize [on|off] â€” at the Scriptorium; hides decoy typography');
    print('  pull book â€” reveals a whimsical title; if it\'s a signal room, the title hides an index word');
    print('  put/insert/place book â€” at the gapped shelf, opens a hidden passage');
    print('  say <WORD> â€” at the Vault, speak the final word');
    print('  maze â€” print an ASCII map (debug). Signals are marked as *.');
    print('  selftest â€” run internal checks');
    print('  seed â€” show world seed (signal placement only); settings â€” open settings; map â€” declines politely; quit â€” clears the screen');
  }

  function parse(cmd){ cmd = (cmd||'').trim(); if(!cmd) return; const raw=cmd; cmd=cmd.toLowerCase();
    if(cmd.includes(';')){ const parts=cmd.split(';').map(s=>s.trim()).filter(Boolean); let i=0; const runNext=()=>{ if(i<parts.length){ issue(parts[i++], true, runNext); } }; runNext(); return; }
    if(['n','north'].includes(cmd)) return move('n');
    if(['e','east'].includes(cmd)) return move('e');
    if(['s','south'].includes(cmd)) return move('s');
    if(['w','west'].includes(cmd)) return move('w');
    if(['l','look','examine','x'].includes(cmd)) return look();
    if(cmd==='help'||cmd==='?') return help();
    if(cmd==='settings'){ settingsDialog.showModal(); return; }
    if(cmd==='seed'){ clearForLastOnly(); print(`Seed: ${seedParam}`); return; }
    if(cmd==='maze'){ clearForLastOnly(); printMaze(); return; }
    if(cmd==='selftest'){ clearForLastOnly(); runSelfTests(); return; }
    if(cmd==='map'){ clearForLastOnly(); print('You try to sketch a plan, but you can\'t seem to draw a reliable map.'); return; }
    if(cmd==='quit'||cmd==='restart'){ view.innerHTML=''; visitTitle=null; intro(); return; }

    if(cmd.startsWith('open ')) return openThing(raw.slice(5));
    if(cmd.startsWith('take ')) return takeThing(raw.slice(5));
    if(cmd.startsWith('read ')) return readThing(raw.slice(5));
    if(cmd==='present card') return presentCard();
    if(cmd.startsWith('normalize')){ return normalizeCmd(raw.slice(9).trim()); }
    if(cmd==='pull book' || cmd==='pull' || cmd==='browse' || cmd==='check shelf' || cmd==='inspect book' || cmd==='take book') return pullBook();
    
    if(cmd.startsWith('say ')) return sayWord(raw.slice(4));
    if(cmd==='put book' || cmd==='insert book' || cmd==='place book' || cmd==='use book' || cmd==='return book') return placeBook();

    if(cmd.startsWith('ask ')){
      if(!atRef(state.x,state.y)){ clearForLastOnly(); print('No one answers.'); return; }
      const about = raw.slice(4).trim();
      if(/(cipher|vigenere|key|card|keyword|index|title|maze)/i.test(about)){ clearForLastOnly(); print('The librarian whispers: "The **issuer** names a key; the **title** names a place in line. Those who love maps may say â€˜mazeâ€™."'); return; }
      clearForLastOnly(); print('The librarian raises an eyebrow and waits.'); return;
    }

    clearForLastOnly();
    print(`I don't understand "${cmd}".`);
    print('Try: help');
  }

  function intro(){
    clearForLastOnly();
    print('Your lantern guttered as you slipped past the roped barrier into the Restricted Stacks.');
    print('A labyrinth of aisles stretches in every direction â€” twisty, almost identical.');
    look();
  }

  /********************
   * Self-tests (dev)  *
   ********************/
  function runSelfTests(){
    const results=[]; const ok=(cond,msg)=>{ results.push((cond?'âœ…':'âŒ')+' '+msg); };
    try { ok(typeof issue==='function', 'issue() is defined'); } catch(e){ ok(false, 'issue() throws'); }
    try { issue('look', true); ok(true, 'can call issue("look")'); } catch(e){ ok(false, 'issue("look") failed: '+e); }
    ok(WIDTH>=7, 'wider maze (WIDTH='+WIDTH+')');

    // Invertibility (one step)
    {
      const exits = exitsMaze(state.x, state.y);
      if(exits.length){
        const dir=exits[0]; const sx=state.x, sy=state.y; move(dir); move(OPP[dir]); ok(state.x===sx && state.y===sy, 'maze step is invertible for one move');
      } else { ok(true, 'start has no exits? (skipped)'); }
    }

    // At least one toroidal wrap exists and behaves as wrap
    let yWrap=-1; for(let y=0;y<HEIGHT;y++){ if((MAZE[`0,${y}`]||{}).w || (MAZE[`${WIDTH-1},${y}`]||{}).e){ yWrap=y; break; } }
    if(yWrap>=0){ const sx=0, sy=yWrap; state.x=sx; state.y=sy; const prevNotes=state.steps; move('w'); ok(state.x===WIDTH-1 && state.y===sy, 'horizontal wrap works (0,y) â†wâ†’ (W-1,y)'); move('e'); ok(state.x===0 && state.y===sy, 'wrap-back east works'); }
    else { ok(false, 'no horizontal wrap added'); }

    // Signal markers appear on map
    const mapLines = asciiMazeLines();
    const gridOnly = mapLines.slice(0, mapLines.length-1).join('');
    const markerCount = (gridOnly.match(/\*/g)||[]).length; // '*' markers only
    ok(markerCount>0, 'signal markers present on map');

    // No signal overlaps a special room
    const overlap = [...SIGNALS.keys()].some(k => used.has(k));
    ok(!overlap, 'no signal overlaps a special');

    // Secret annex is a signal, and shelf starts blocked
    ok(SIGNALS.has(SECRET_ANNEX_KEY), 'secret annex is a signal room');
    ok(!(MAZE[SECRET_SHELF_KEY]||{})[SECRET_SHELF.dir], 'secret shelf initially blocked');

    // Exactly SIGNAL_COUNT signals present and ciphertext length matches
    ok(SIGNALS.size === SIGNAL_COUNT, 'exactly '+SIGNAL_COUNT+' signal rooms');

    print('Self-tests:', 'muted'); results.forEach(r=>print('  '+r, 'muted'));
  }

  // Boot (robust)
  async function boot(){
    try{
      // Server mode: no ciphertext/signals loaded on client
      intro();
      if(runSelfTestsParam){ runSelfTests(); }
      const form = document.getElementById('cmdbar');
      if(form){
        form.addEventListener('submit', (e)=>{ e.preventDefault(); const val=cmdInput.value; cmdInput.value=''; issue(val); });
      }
      const obs = new MutationObserver(()=>{ if(view){ view.scrollTop = view.scrollHeight; } });
      if(view){ obs.observe(view, {childList:true}); }
    }catch(e){
      const fallback = document.getElementById('view') || document.body;
      const div = document.createElement('div');
      div.className='line muted';
      div.textContent = 'Startup error: ' + (e && e.message ? e.message : e);
      fallback.appendChild(div);
      console.error(e);
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot);
  } else {
    boot();
  }
  </script>
</body>
</html>
