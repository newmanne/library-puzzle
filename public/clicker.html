<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Library Clicker</title>
  <style>
    :root{
      --bg:#0e0f13; /* very dark slate */
      --panel:#151823;
      --ink:#f5f7ff;
      --muted:#b6bdd3;
      --accent:#81e6d9;
      --accent-2:#ffd166;
      --danger:#ff6b6b;
      --good:#8aff8a;
    }
    html,body{height:100%;}
    body{
      margin:0; font:16px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Noto Color Emoji;
      color:var(--ink); background:linear-gradient(180deg,#0b0c12 0%, var(--bg) 100%);
    }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:1rem;
      padding:16px 20px; background:#0b0d14; position:sticky; top:0; z-index:10; box-shadow:0 2px 0 rgba(255,255,255,0.04) inset;
    }
    header h1{font-weight:800; letter-spacing:.5px; font-size:20px; margin:0; position:relative}
    .tag{font-size:12px; color:var(--muted);}

    .wrap{display:grid; grid-template-columns: 1.3fr .9fr; gap:18px; padding:18px; max-width:1100px; margin:0 auto;}

    .card{background:var(--panel); border:1px solid rgba(255,255,255,.06); border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.25);}
    .card h2{margin:0; padding:12px 14px; font-size:14px; letter-spacing:.4px; color:var(--muted); border-bottom:1px solid rgba(255,255,255,.06)}
    .card .body{padding:14px}
    /* Make ghostLink header link visible but not blue */
    #play h2 a{ color:inherit; text-decoration:underline; text-decoration-thickness:1px; text-underline-offset:2px; }
    #play h2 a:visited{ color:inherit; }
    #play h2 a:hover{ text-decoration-thickness:2px; }

    .stats{display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:10px; margin-bottom:10px}
    .stat{background:#0f1220; border:1px solid rgba(255,255,255,.06); border-radius:12px; padding:10px}
    .stat .v{font-weight:800; font-size:20px}
    .stat .k{color:var(--muted); font-size:12px}

    .bookzone{display:grid; place-items:center; padding:20px 0 10px}
    .book{cursor:pointer; width:220px; height:300px; border-radius:14px; border:1px solid rgba(255,255,255,.08); background:linear-gradient(145deg,#26324a,#1a2640); position:relative; display:grid; place-items:center; transition:transform .06s ease;
      box-shadow:0 20px 50px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.05);
    }
    .book:active{transform:translateY(1px) scale(.995)}
    .book::before{content:""; position:absolute; inset:0; border-radius:14px; box-shadow:inset 0 0 0 2px rgba(129,230,217,.15), inset 0 0 40px rgba(129,230,217,.06);}
    .book .label{font-weight:700; letter-spacing:.4px; color:#d6e1ff}

    .controls{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:8px}
    .control{background:#0f1321; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:8px 10px; color:var(--muted); font-size:12px}
    .toggle{display:inline-flex; align-items:center; gap:8px; cursor:pointer; user-select:none}
    .toggle input{appearance:none; width:36px; height:20px; background:#2a3248; border-radius:999px; position:relative; outline:none; border:1px solid rgba(255,255,255,.15)}
    .toggle input:checked{background:#23403b}
    .toggle input::after{content:""; position:absolute; top:2px; left:2px; width:14px; height:14px; border-radius:50%; background:#c1c8de; transition:left .18s ease}
    .toggle input:checked::after{left:20px; background:#8aff8a}

    .shop-item{display:flex; justify-content:space-between; align-items:center; gap:12px; padding:10px; border-top:1px solid rgba(255,255,255,.06)}
    .shop-item:first-child{border-top:none}
    .shop-item button{background:#1b2134; color:var(--ink); border:1px solid rgba(255,255,255,.12); padding:8px 10px; border-radius:10px; cursor:pointer}
    .shop-item button:disabled{opacity:.45; cursor:not-allowed}

    dialog{border:none; border-radius:14px; padding:0; background:#0e1220; color:var(--ink); width:min(520px, 92vw)}
    dialog .dhd{padding:14px 16px; border-bottom:1px solid rgba(255,255,255,.08); background:#0c101b}
    dialog .dbd{padding:16px}
    dialog .dfx{display:flex; justify-content:flex-end; gap:10px; padding:0 16px 16px}

    /* Subtle clue layers */
    #watermark{position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; opacity:0; transition:opacity .2s ease}
    #watermark span{font-weight:800; font-size:32px; letter-spacing:4px; text-transform:uppercase; filter:blur(.2px);}

    /* White-on-white hidden text container */
    #hidden-white{color:var(--bg); user-select:text}

    /* Error banner when close to 1000 */
    .near-thousand{outline:2px dashed rgba(255,255,255,.15)}

    .muted{color:var(--muted)}
    .accent{color:var(--accent)}

    /* Tiny helper link (for code 604) */
    .ghost-link{position:absolute; right:8px; bottom:8px; font-size:11px; opacity:.06}

    /* Black text hint appended to Stacks header */
    .black-hint{ color:#000; margin-left:8px; font-size:12px; letter-spacing:.2px; }

    /* Responsive */
    @media (max-width: 900px){
      .wrap{grid-template-columns: 1fr}
    }
  
    /* SVG book art + click thump */
    .book svg{width:72%; height:auto; pointer-events:none}
    .book.thump{animation:thump .09s linear}
    @keyframes thump{0%{transform:translateY(0) scale(1)}50%{transform:translateY(1px) scale(.992)}100%{transform:translateY(0) scale(1)}}
  
    /* Pop-over +N bubbles */
    .pop{position:absolute; left:50%; top:50%; pointer-events:none; font-weight:800; font-size:14px; opacity:0; animation:pop .8s ease-out; white-space:nowrap}
    .pop.click{color:var(--good); text-shadow:0 2px 6px rgba(0,0,0,.3)}
    .pop.auto{color:var(--accent)}
    @keyframes pop{
      0%{opacity:0; transform:translate(-50%,-30%) scale(.9)}
      25%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-80%) scale(1)}
    }

    /* Tiny header micro note under title (no layout shift) */
    .micro-hint{ position:absolute; left:0; top:100%; margin-top:2px; font-size:8px; line-height:1; color:var(--muted); letter-spacing:.2px; pointer-events:none; white-space:nowrap; }

    /* Shelf label (strip under the Stacks header) */
    
  </style>
</head>
<body>
  <header>
    <h1 aria-live="polite">Library Clicker <span class="tag"></span></h1>
    <div class="controls">
<label id="pauseWrap" class="toggle control"><input id="pauseAutos" type="checkbox"/> Pause autos</label> <button class="control" id="resetAll">Reset all progress</button> <button class="control" id="skipNextCode" style="display:none">Skip to next code - 1</button> </div> </header> <main class="wrap"> <!-- Left: play area --> <section class="card" id="play"> <h2>Stacks</h2> <div class="body"> <div class="stats"> <div class="stat"><div class="v" id="count">0</div><div class="k">Books shelved</div></div> <div class="stat"><div class="v" id="rate">0/sec</div><div class="k">Auto rate</div></div> <div class="stat" id="creditsStat"><div class="v" id="credits">0</div><div class="k">Credits</div></div> </div> <div class="bookzone"> <button id="book" class="book" aria-label="Return a book" title="Click" type="button"> <svg viewBox="0 0 240 320" role="img" aria-hidden="true"> <defs> <linearGradient id="cov" x1="0" y1="0" x2="1" y2="1"> <stop offset="0" stop-color="#3b82f6"/> <stop offset="1" stop-color="#1d4ed8"/> </linearGradient> </defs> <!-- cover --> <rect x="36" y="28" width="168" height="250" rx="14" fill="url(#cov)" /> <!-- spine --> <rect x="24" y="28" width="20" height="250" rx="6" fill="#1e293b"/> <!-- title band --> <rect x="44" y="40" width="148" height="14" rx="7" fill="rgba(255,255,255,0.15)"/> <!-- plate area --> <rect x="44" y="66" width="148" height="160" rx="10" fill="rgba(255,255,255,0.07)"/> <!-- footer band --> <rect x="44" y="232" width="148" height="28" rx="6" fill="rgba(0,0,0,0.15)"/> <!-- page shadow / base --> <path d="M204 278 L204 298 C204 306 196 312 188 310 L44 282" fill="#0b0e17"/> <!-- bookmark ribbon --> <path d="M92 88 L108 88 108 148 100 142 92 148 Z" fill="#e11d48"/> </svg> <div id="watermark"><span></span></div> <div class="label">Click to shelve</div> <a id="mapLink" class="ghost-link" href="#" aria-label="Stacks map" hidden>map</a> </button> </div> <div class="controls"> <div class="control" id="status"></div> </div> </div> </section>
    <!-- Right: upgrades -->
    <aside class="card" id="shop">
      <h2>Upgrades</h2>
      <div class="body" id="shopItems"></div>
    </aside>
  </main>

  <dialog id="crash">
    <div class="dhd">
      <strong style="color:var(--danger)">SYSTEM CRASH</strong>
    </div>
    <div class="dbd">
      <p>An unexpected error has occured.</p>
      <p><strong>Error code: <span id="errCode">000</span></strong></p>
      <p class="muted">The system will now reset to zero.</p>
    </div>
    <div class="dfx">
      <button id="restart" style="background:var(--accent); color:#0b0c12; border:none; font-weight:700; padding:10px 12px; border-radius:10px; cursor:pointer">OK</button>
    </div>
  </dialog>

  <script>
  // -------------------- CONFIG --------------------
  // Special events are now served from the server at /api/clicker-event
  async function fetchEventByCode(code){
    try{
      const r = await fetch(`/api/clicker-event?code=${encodeURIComponent(code)}`);
      const data = await r.json();
      if(data && data.ok && data.event) return data.event;
    }catch(_){ /* ignore */ }
    return null;
  }
  async function fetchRandomErrorCode(excludeCodes){
    try{
      const q = excludeCodes && excludeCodes.length ? `&exclude=${excludeCodes.join(',')}` : '';
      const r = await fetch(`/api/clicker-event?random=1${q}`);
      const data = await r.json();
      if(data && data.ok && data.code) return data.code;
    }catch(_){ /* ignore */ }
    return Math.floor(Math.random()*900)+100; // fallback
  }

  const UPGRADE_DEFS = [
    { id:'intern', name:'Pageâ€‘turner Intern', baseCost: 100, perSec: 1,  desc:'+1/sec' },
    { id:'cart',   name:'Rolling Cart',       baseCost: 200, perSec: 5,  desc:'+5/sec' },
    { id:'robot',  name:'Sorting Robot',      baseCost: 300, perSec: 8, desc:'+8/sec' },
    { id:'rfid',   name:'RFID Gate',          baseCost: 500, perSec: 15, desc:'+15/sec' }
  ];

  const STORAGE_KEY = 'libraryClicker.v1';

  // -------------------- STATE --------------------
  let state = {
    count: 0,
    lifetime: 0,
    credits: 0,
    upgrades: {},
    pauseAutos: false,
    seenCrash: false,
    usedErrorCodes: [],
    found: []
  };

  // Load state
  const saved = localStorage.getItem(STORAGE_KEY);
  if(saved){ try{ state = {...state, ...JSON.parse(saved)} }catch{} }
  UPGRADE_DEFS.forEach(u=>{ if(!(u.id in state.upgrades)) state.upgrades[u.id]=0; });

  const urlParams = new URLSearchParams(location.search);
  // Dev helper: skip first-crash gating to unlock shop/credits immediately
  if(urlParams.get('unlock')==='1' || urlParams.get('skipCrash')==='1'){
    state.seenCrash = true;
  }

  // -------------------- DOM --------------------
  const elCount = document.getElementById('count');
  const elRate = document.getElementById('rate');
  const elCredits = document.getElementById('credits');
  const elBook = document.getElementById('book');
  const elStatus = document.getElementById('status');
  // Lazy getters to avoid timing race with DOM
  const getWatermark = () => document.getElementById('watermark');
  const getWatermarkText = () => { const wm = getWatermark(); return wm ? wm.querySelector('span') : null; };
  const elShop = document.getElementById('shopItems');
  const elPause = document.getElementById('pauseAutos');
  const elPauseWrap = document.getElementById('pauseWrap');
  const elCrash = document.getElementById('crash');
  const elErrCode = document.getElementById('errCode');
  const elRestart = document.getElementById('restart');
  
  const elMap = document.getElementById('mapLink');
  const elResetAll = document.getElementById('resetAll');
  const elSkipNext = document.getElementById('skipNextCode');
  const elCreditsStat = document.getElementById('creditsStat');
  const elShopPanel = document.getElementById('shop');

  // -------------------- UTILS --------------------
  function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
  function fmt(n){ return n.toLocaleString(); }
  function totalRate(){ return UPGRADE_DEFS.reduce((a,u)=> a + Math.min(1, (state.upgrades[u.id]||0))*u.perSec, 0); }
  function nextCost(u){ const q = state.upgrades[u.id]||0; return Math.floor(u.baseCost * Math.pow(1.15, q)); }

  function renderShop(){
    if(!state.seenCrash){
      // Keep shop empty until first crash has occurred
      if (elShop) elShop.innerHTML = '';
      return;
    }
    elShop.innerHTML = '';
    UPGRADE_DEFS.forEach(u=>{
      const owned = (state.upgrades[u.id]||0) >= 1;
      const cost = nextCost(u);
      const can = !owned && state.credits >= cost;
      const row = document.createElement('div'); row.className='shop-item';
      row.innerHTML = `
        <div>
          <div><strong>${u.name}</strong> <span class="muted">Ã—${Math.min(1, state.upgrades[u.id]||0)}</span></div>
          <div class="muted" style="font-size:12px">${u.desc}</div>
        </div>
        <div style="display:flex; align-items:center; gap:8px">
          <div class="muted" style="font-size:12px">${owned ? 'Owned' : 'Cost: '+fmt(cost)}</div>
          <button data-upg="${u.id}" ${can?'':'disabled'}>${owned ? 'Owned' : 'Buy'}</button>
        </div>`;
      const btn = row.querySelector('button');
      btn.addEventListener('click', ()=>{
        if ((state.upgrades[u.id]||0) >= 1){ tickRender(); return; }
        const c = nextCost(u);
        if(state.credits < c){ tickRender(); return; }
        state.credits -= c;
        state.upgrades[u.id] = 1;
        save();
        tickRender();
      });
      elShop.appendChild(row);
    });
  }

  function tickRender(){
    if (elCount)   elCount.textContent   = fmt(state.count);
    if (elRate)    elRate.textContent    = `${fmt(totalRate())} / sec`;
    if (elCredits) elCredits.textContent = fmt(state.credits);

    // Update shop enable/disable state as credits change
    renderShop();

    // subtle highlight when near 1000
    if(state.count >= 980 && state.count < 1000){ elBook.classList.add('near-thousand'); }
    else { elBook.classList.remove('near-thousand'); }
  };

  function addBooks(n, {source='auto'}={}){
    function inc(m){
      state.count += m; state.lifetime += m;
      // Credits accrue only for manual clicks after first crash is unlocked
      if (source === 'click' && state.seenCrash){ state.credits += m; }
      checkSpecials(); save(); tickRender();
    }

    if(source==='auto'){
      const cap = Math.max(0, 999 - state.count);
      n = Math.min(n, cap);
      if(n<=0) return; inc(n); return;
    }

    // Manual: any attempt at/after 999 triggers crash
    if(state.count >= 999){ openCrash(); return; }
    inc(n);
  }

  async function openCrash(){
    // Ensure unique-per-round: if we've seen all codes, start a fresh round
    try{
      const all = await fetchEventCodes();
      if (Array.isArray(all) && all.length){
        const seen = new Set(state.usedErrorCodes);
        const seenCount = all.reduce((n,c)=> n + (seen.has(c)?1:0), 0);
        if (seenCount >= all.length){ state.usedErrorCodes = []; }
      }
    }catch(_){ /* ignore network issues; fall back to server logic */ }

    const code = await fetchRandomErrorCode(state.usedErrorCodes);
    if (!state.usedErrorCodes.includes(code)) state.usedErrorCodes.push(code);
    if (elErrCode) elErrCode.textContent = code;
    save();
    if(typeof elCrash.showModal === 'function') elCrash.showModal(); else alert(`SYSTEM CRASH â€” Error code ${code}`);
  }
  function restartShift(){
    state.count = 0;
    if(!state.seenCrash) state.seenCrash = true; // unlock post-crash UI after first crash
    // Reset auto accumulators so a new shift always starts clean
    try{ autoBucket = 0; autoPopAcc = 0; lastAutoPop = performance.now(); }catch(_){ }
    save();
    updatePhaseUI();
    tickRender();
    closeCrash();
  }
  function closeCrash(){ if(elCrash.open) elCrash.close(); }

  // -------------------- SPECIAL EVENTS --------------------
  function clearSubtleties(){
    // wipe all transient hint surfaces (applies to EVERY special type)
    if (elBook){
      elBook.removeAttribute('title');
      elBook.setAttribute('aria-label','Return a book');
      elBook.style.cursor = 'pointer'; // reset from cursorTip
    }
    { const wm = getWatermark(); if(wm) wm.style.opacity = 0; const wmt = getWatermarkText(); if(wmt) wmt.textContent = ''; }
    
    document.title = 'Library Clicker';
    if (elStatus){ elStatus.textContent=''; elStatus.removeAttribute('role'); elStatus.style.background = 'transparent'; }
    if (elMap){ elMap.hidden = true; elMap.removeAttribute('title'); elMap.href = '#'; }
    // Reset "Stacks" heading to plain text if ghostLink modified it
    {
      const h = document.querySelector('#play h2');
      if (h) h.textContent = 'Stacks';
    }
    // Remove subtle header hints
    { document.querySelectorAll('.black-hint, .micro-hint').forEach(n=>n.remove()); }
    const hhd = document.querySelector('header h1'); if (hhd) hhd.dataset.after = '';
    // Restore the primary stat label
    { const kc = document.getElementById('count'); if(kc){ const st = kc.closest('.stat'); if(st){ const kl = st.querySelector('.k'); if(kl) kl.textContent = 'Books shelved'; } } }
    const lbl = document.querySelector('.label'); if (lbl) lbl.style.textShadow = 'none';
  }
  
  let lastSpecialChecked = -1;
  async function checkSpecials(){
    // Before first crash, suppress all special events entirely
    if(!state.seenCrash){ return; }
    if(state.count === lastSpecialChecked) return; // avoid refetching
    lastSpecialChecked = state.count;
    clearSubtleties();
    const s = await fetchEventByCode(state.count);
    if(!s) return;
    switch(s.type){
      case 'watermark':
        { const wmt = getWatermarkText(); if(wmt) wmt.textContent = s.text; } { const wm = getWatermark(); if(wm) wm.style.opacity = .08; } break;
      case 'ariaNote':
        if (elStatus){ elStatus.textContent = s.text; elStatus.setAttribute('role','status'); } break;
      case 'ghostLink':
        {
          const h = document.querySelector('#play h2');
          if (h){
            const a = document.createElement('a');
            a.textContent = 'Stacks';
            const q = encodeURIComponent(s.text||'');
            a.href = `https://www.google.com/search?q=${q}`;
            a.target = '_blank';
            a.rel = 'noopener noreferrer';
            h.innerHTML = '';
            h.appendChild(a);
          }
        }
        
        break;
      case 'blackText':
        {
          const h = document.querySelector('#play h2');
          if (h){
            const t = document.createElement('span');
            t.className = 'black-hint';
            t.textContent = ' ' + s.text;
            h.appendChild(t);
          }
        }
        break;
      case 'bookBadge':
        {
          const hh = document.querySelector('header h1');
          if (hh){
            // remove any existing micro-hint before adding a new one
            hh.querySelectorAll('.micro-hint').forEach(n=>n.remove());
            const m = document.createElement('span');
            m.className = 'micro-hint';
            m.textContent = s.text;
            // enforce tiny styling inline to avoid any cascade surprises
            m.style.position = 'absolute';
            m.style.left = '0';
            m.style.top = '100%';
            m.style.marginTop = '2px';
            m.style.fontSize = '8px';
            m.style.lineHeight = '1';
            m.style.color = 'var(--muted)';
            m.style.letterSpacing = '.2px';
            m.style.pointerEvents = 'none';
            m.style.whiteSpace = 'nowrap';
            hh.appendChild(m);
          }
        }
        break;
      case 'headerAfter':
        {
          // Repurpose: render clue as the primary stat label instead of under-title text
          const kc = document.getElementById('count');
          if (kc){
            const st = kc.closest('.stat');
            if (st){
              const kl = st.querySelector('.k');
              if (kl) kl.textContent = s.text;
            }
          }
        }
        break;
    }
  }
  function addHeaderAfterCSS(){
    if(document.getElementById('after-style')) return;
    const st = document.createElement('style'); st.id='after-style';
    // Render under the title without affecting layout of the right-side controls
    st.textContent = `header h1{position:relative} header h1::after{content: attr(data-after); position:absolute; left:0; top:100%; margin-top:4px; color: ${getComputedStyle(document.documentElement).getPropertyValue('--muted')}; font-size:12px; white-space:nowrap; pointer-events:none; z-index:2}`;
    document.head.appendChild(st);
  }
// -------------------- POP BUBBLES --------------------
function spawnPop(text, variant='click'){
  const s = document.createElement('span');
  s.className = `pop ${variant}`;
  s.textContent = text;
  s.style.marginLeft = (Math.random()*34 - 17) + 'px';
  s.style.marginTop  = (Math.random()*12 -  6) + 'px';
  elBook.appendChild(s);
  const cleanup = ()=> s.remove();
  s.addEventListener('animationend', cleanup, {once:true});
  setTimeout(cleanup, 1200);
}

  // -------------------- LOOP --------------------
  let last = performance.now();
  let autoBucket = 0;
  let autoPopAcc = 0;
  let lastAutoPop = 0;
  const AUTO_POP_INTERVAL_MS = 300; // ~3 pops/sec
  function loop(now){
    const dt = (now - last) / 1000; last = now;

    if(!state.pauseAutos){
      autoBucket += totalRate() * dt;
      const potential = Math.floor(autoBucket);
      const allowed = Math.max(0, 999 - state.count);
      if (allowed === 0){
        // At cap: discard any accumulated autos so they don't burst after restart
        autoBucket = 0;
      } else if(potential>0){
        const actual = Math.min(potential, allowed);
        if (actual > 0){
          autoBucket -= actual;
          addBooks(actual, {source:'auto'});
          autoPopAcc += actual;
        }
      }
    }

    // Throttled auto bubble
    const t = performance.now();
    if (autoPopAcc > 0 && (t - lastAutoPop) >= AUTO_POP_INTERVAL_MS){
      spawnPop('+'+autoPopAcc, 'auto');
      autoPopAcc = 0;
      lastAutoPop = t;
    }

    // Re-evaluate specials EVERY frame so clues vanish unless count === code
    checkSpecials();

    requestAnimationFrame(loop);
  };
  // Events
  if (elBook) elBook.addEventListener('click', ()=>{
    // ensure manual click from 999 -> crash
    if (state.count >= 999) { openCrash(); return; }
    elBook.classList.add('thump');
    setTimeout(()=>elBook.classList.remove('thump'), 90);
    addBooks(1, {source:'click'});
    spawnPop('+1','click');
  });
  if (elRestart) elRestart.addEventListener('click', restartShift);
  if (elPause)   elPause.addEventListener('change', ()=>{ state.pauseAutos = elPause.checked; save(); });
  if (elResetAll) elResetAll.addEventListener('click', ()=>{
    if (confirm('Reset all progress? This will erase upgrades, credits, and shift counts.')){
      localStorage.removeItem(STORAGE_KEY);
      location.reload();
    }
  });
  // (journal toggle removed)

  // -------------------- INIT --------------------
  async function fetchEventCodes(){
    const fallback = [133,343,398,423,520,737,937,952,993];
    try{
      const r = await fetch('/api/clicker-event');
      const data = await r.json();
      if(data && data.ok && Array.isArray(data.codes)){
        const arr = data.codes.slice().sort((a,b)=>a-b);
        return arr.length ? arr : fallback;
      }
    }catch(_){ /* ignore */ }
    return fallback;
  }
  function updatePhaseUI(){
    const unlocked = !!state.seenCrash;
    // Toggle visibility of UI elements that should be hidden before first crash
    if (elPauseWrap) elPauseWrap.style.display = unlocked ? '' : 'none';
    if (elCreditsStat) elCreditsStat.style.display = unlocked ? '' : 'none';
    if (elShopPanel) elShopPanel.style.display = unlocked ? '' : 'none';
    const rateStat = elRate ? elRate.closest('.stat') : null;
    if (rateStat) rateStat.style.display = unlocked ? '' : 'none';
  }
  async function initUI(){
  updatePhaseUI();
  renderShop();
  tickRender();
  checkSpecials();
  // Enable debug skip if requested
  if (urlParams.get('debug')==='1' && elSkipNext){
    elSkipNext.style.display = '';
    elSkipNext.addEventListener('click', async ()=>{
      const codes = await fetchEventCodes();
      if(!codes.length){
        alert('Could not load event codes. Is the API running?');
        return;
      }
      const future = codes.filter(c => c > state.count);
      if(!future.length){
        alert('No later event codes from here. Try restarting the shift.');
        return;
      }
      const next = future[0];
      const target = Math.max(0, next - 1);
      const delta = target - state.count;
      if (delta > 0){
        state.count += delta;
        state.lifetime += delta;
        state.credits += delta;
        save();
        tickRender();
        checkSpecials();
      }
    });
  }
  requestAnimationFrame(loop);
}
if (document.readyState === 'loading'){
  document.addEventListener('DOMContentLoaded', initUI);
} else {
  initUI();
}
  </script>
</body>
</html>
